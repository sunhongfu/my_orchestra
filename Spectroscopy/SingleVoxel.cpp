// Copyright 2018 General Electric Company. All rights reserved.
// GE Proprietary and Confidential Information. Only to be distributed with
// permission from GE. Resulting outputs are not for diagnostic purposes.

#include <boost/shared_ptr.hpp>
#include <boost/filesystem.hpp>

#include <Dicom/Types.h>
#include <Dicom/MR/Image.h>

#include <Hdf5/File.h>

#include <MDArray/Fourier.h>
#include <MDArray/MDArray.h>

#include <Orchestra/Common/ImageCorners.h>

#include <Orchestra/Legacy/DicomSeries.h>
#include <Orchestra/Legacy/Pfile.h>
#include <Orchestra/Legacy/LegacyImageDB.h>

#include <Orchestra/Control/ProcessingControl.h>

#include <Orchestra/Spectro/SingleVoxel/LxControlSource.h>
#include <Orchestra/Spectro/SingleVoxel/SingleVoxelWorker.h>
#include <Orchestra/Spectro/SingleVoxel/SingleVoxelPlot.h>

#include "SingleVoxel.h"

using namespace MDArray;
using namespace GERecon;
using namespace GERecon::Control;
using namespace GERecon::Spectro;
using namespace GERecon::Spectro::SingleVoxel;
using namespace GERecon::Legacy;

void GERecon::Spectro::Rehearsal::SingleVoxelRecon(const std::string& pfilePath) // parasoft-suppress  METRICS-22 "Procedural rehearsal code"
{    
    //// Load Pfile
    // Instantiate a pfile object using the Pfile path supplied to this function
    // Hold on to the Pfile path as this path will be used to save the
    // single voxel DICOM image generated by this function.
    // Also, instantiate a processing control object. Processing control interprets
    // parameters from the Pfile header, storing them as name/value pairs.
    boost::shared_ptr<Pfile> pfilePointer = Pfile::Create(pfilePath);
    const boost::filesystem::path pfileFullFilePath(pfilePath);
    const boost::shared_ptr<Control::ProcessingControl> processingControl = pfilePointer->CreateOrchestraProcessingControl<SingleVoxel::LxControlSource>();

    const int numReferenceFids = processingControl->Value<int>("NumReferenceFIDs");
    const int acquiredFidLength = processingControl->Value<int>("AcquiredXRes");
    const int transformSize = processingControl->Value<int>("SpectralTransformSize");
    const int bandwidth = processingControl->Value<int>("SpectralBandwidth");
    const int numChannels = processingControl->Value<int>("NumChannels");
    const bool chop = processingControl->Value<bool>("ChopFidAccumulation");
    const int nexValue = processingControl->Value<int>("SingleVoxelSpectroNex");
    const float lowestPpmToPlot = processingControl->Value<float>("LowestPpmToPlot");
    const float ppmRangeToPlot = processingControl->Value<float>("PpmRangeToPlot");
    const GERecon::Legacy::MrImageDataTypeStruct& imageHeader = boost::const_pointer_cast<const LxDownloadData>(pfilePointer->DownloadData())->ImageHeaderData();

    // Initialize a dicom series object to use for saving the single voxel DICOM image
    const GERecon::Legacy::DicomSeries dicomSeries(pfilePointer, Legacy::DicomSeries::SeriesTimes100);

    //// Extract processing options from processing control for each type of FID
    // (Water-Suppressed Signal, Non-Water-Suppressed Reference, Accumulated Water-Suppressed-Reference Reference)
    // This structure contains the following fields. To override any of the options, remove the const keyword
    // from the structure declaration line below and modify the desired fields. The processing options
    // contained in processing control are the product processing options for the data contained
    // in the Pfile.
    // Options in Single Voxel Processing Options Structure:
    //    normalize
    //    lowPassFilter
    //    shiftMaximumMagnitudeFrequencyToDc
    //    subtractPhaseOfFirstPointInFid
    //    removeLinearPhaseTrend
    //    smoothedPhaseRemoval
    const SingleVoxel::Options signalFrameProcessingOptions = SingleVoxelWorker::ProcessingOptions(*processingControl, SingleVoxelWorker::SignalFrame);
    const SingleVoxel::Options referenceFrameProcessingOptions = SingleVoxelWorker::ProcessingOptions(*processingControl, SingleVoxelWorker::ReferenceFrame);
    const SingleVoxel::Options accumulatedFrameProcessingOptions = SingleVoxelWorker::ProcessingOptions(*processingControl, SingleVoxelWorker::AccumulatedReferenceFrame);

    // Create a debug hdf5 file. This file will be created in the same directory that this rehearsal is running from.
    // This file contains debug data in the HDF5 file format. The data can be read into MATLAB for intermediate
    // data analysis.
    boost::filesystem::path debugFilePath = pfileFullFilePath.parent_path() / "singleVoxelDebug.h5";
    const GEHdf5::File svDebugFile(debugFilePath.string(), GEHdf5::File::Overwrite);

    // Initialize space for intermediate individual channel data outside of the channel loop for improved efficiency
    ComplexFloatVector combinedSignalFid(acquiredFidLength);
    ComplexFloatVector combinedReferenceFid(acquiredFidLength);
    ComplexFloatVector phaseCorrectionVector(acquiredFidLength);

    // Initialize channel combination space and scalar weight
    ComplexFloatVector channelCombinedReference(acquiredFidLength);
    ComplexFloatVector channelCombinedSignal(acquiredFidLength);
    channelCombinedReference = 0.0f;
    channelCombinedSignal = 0.0f;
    float accumulatedChannelWeight = 0.0f;
        
    for(int currentChannel = 0; currentChannel < numChannels; ++currentChannel)
    {
        
        //// Extract raw data
        // Single voxel scans do not use the slice or echo dimension; thus,
        // set both the slice and echo indices to one. Extract all views 
        // for the current channel. Each view is one acquired FID and is 
        // either a water-suppressed signal FID or a non-water-suppressed 
        // reference FID. The signal and reference FIDs are extracted 
        // separately below. The non-water-suppressed reference FIDs are 
        // always ordered in the Pfile before the water-suppressed signal 
        // FIDs for product scans. The first dimension of the raw data is
        // the time index and the second dimension is the view (or FID)
        // index.
        // The data in the Pfile has been accumulated based on how many
        // NEX's were prescribed. However, the data has not been scaled back
        // down based on the number of NEX's.
        const int slice = 0;
        const int echo = 0;
        ComplexFloatMatrix allChannelData = pfilePointer->KSpaceData<float>(slice, echo, currentChannel);
        allChannelData /= static_cast<float>(nexValue);

        //// Process signal FIDs
        // Process each water-suppressed signal FID that was acquired for 
        // this channel and combine them into a single water-suppressed 
        // signal FID. If RF chopping was enabled then every other FID is
        // negated.
        // Note that water-suppressed-signal FIDs are always ordered in the
        // Pfile after the non-water-suppressed reference FIDs.
        // The processing steps applied to each water-suppressed signal FID
        // are specified in the params structure. A description of each
        // processing step can be found in the ProcessFid function below.
        const ComplexFloatMatrix signalFids = allChannelData(Range::all(), Range(numReferenceFids, toEnd));
        combinedSignalFid = 0.0f;
        for(int fidIndex = 0; fidIndex < signalFids.extent(secondDim); ++fidIndex)
        {
            ComplexFloatVector fidToProcess = signalFids(Range::all(),fidIndex);
            ProcessFid(phaseCorrectionVector, fidToProcess, signalFrameProcessingOptions, transformSize);
            
            if(chop && ((fidIndex % 2) != 0))
            {
                fidToProcess *= -1.0f;
            }
            
            fidToProcess /= static_cast<float>(signalFids.extent(secondDim));
            combinedSignalFid += fidToProcess;
        }
        
        //// Process reference FIDs
        // If non-water-suppressed reference FIDs were acquired for this
        // channel, process them and combine them into a single
        // non-water-suppressed reference FID. The combined non-water
        // suppressed reference FID is processed one more time and the phase
        // correction vector applied to the combined non-water-suppressed
        // reference FID is also applied to the combined water-suppressed
        // signal FID. The phase correction vector contains the same phase
        // shifts applied to the combinedReferenceFid. Thus, when multiplied
        // with the signal FID, these phase shifts are also applied to the
        // signal FID.
        combinedReferenceFid = 0.0f;
        float weight = 1.0f;
        if(numReferenceFids > 0)
        {
            ComplexFloatMatrix referenceFidsToProcess = allChannelData(Range::all(), Range(0,(numReferenceFids-1)));

            for(int fidIndex = 0; fidIndex < referenceFidsToProcess.extent(secondDim); ++fidIndex)
            {
                ComplexFloatVector fidToProcess = referenceFidsToProcess(Range::all(),fidIndex);
                ProcessFid(phaseCorrectionVector, fidToProcess, referenceFrameProcessingOptions, transformSize);

                if(chop && ((fidIndex % 2) != 0))
                {
                    fidToProcess *= -1.0f;
                }

                fidToProcess /= static_cast<float>(referenceFidsToProcess.extent(secondDim));
                combinedReferenceFid += fidToProcess;
            }

            // Use the reference frame for multi-channel coil weighting
            FloatVector magSquared(combinedReferenceFid.shape());
            magSquared = MDArray::abs(combinedReferenceFid) * MDArray::abs(combinedReferenceFid);
            weight = MDArray::max(magSquared);

            ProcessFid(phaseCorrectionVector, combinedReferenceFid, accumulatedFrameProcessingOptions, transformSize);

            combinedSignalFid *= phaseCorrectionVector;
        }
        else
        {
            // use the signal frame for multi-channel coil weighting
            FloatVector magSquared(combinedSignalFid.shape());
            magSquared = MDArray::abs(combinedSignalFid) * MDArray::abs(combinedSignalFid);
            weight = MDArray::max(magSquared);
        }

        const bool generateIntermediateChannelImages = true;
        if(generateIntermediateChannelImages)
        {
            GenerateChannelImages(combinedSignalFid, combinedReferenceFid, lowestPpmToPlot, ppmRangeToPlot, *processingControl, svDebugFile, currentChannel);
        }

        //// Accumulate Multi-Channel Data
        // Individual channel data is scaled by the maximum magnitude
        // squared of the non-water-suppressed reference FID (if 
        // non-water-suppressed reference FIDs ARE acquired) or by the 
        // maximum magnitude squared of the water-suppressed signal FID 
        // (if non-water-suppressed reference FIDs are NOT acquired).
        // The cumulative channel weights are saved to scale the channel
        // combined FIDs back down after the channel combine.
        accumulatedChannelWeight += weight;
        weight = std::sqrt(weight);
        channelCombinedReference += combinedReferenceFid * weight;
        channelCombinedSignal += combinedSignalFid * weight;
    }

    //// Water Subtraction
    // Water subtraction uses a non-water-suppressed reference FID to
    // estimate the residual water contribution to the water-suppressed
    // FID's signal. The residual water signal in the water-suppressed
    // signal FID is subtracted. 
    if(processingControl->Value<bool>("SubtractWater"))
    {
        Common::SubtractWater(channelCombinedReference, channelCombinedSignal, numReferenceFids, bandwidth, acquiredFidLength, transformSize);
    }

    //// Multi-Channel Scaling
    // Scale down the combined channel data based on the cumulative 
    // weight accumulated in the channel loop above.
    float multiChannelScalar = std::sqrt(accumulatedChannelWeight);
    if(std::abs(multiChannelScalar) > std::numeric_limits<float>::min())
    {
        channelCombinedReference /= multiChannelScalar;
        channelCombinedSignal /= multiChannelScalar;
    }
    
    //// Quantitation
    // Quantitate the spectrum using the GE Single Voxel Spectroscopy
    // quantitation algorithm. The algorithm parameters will be taken from
    // the processing control object passed in to the function. This algorithm
    // will filter and perform a Fourier transform internally. Thus, the
    // input data must be in the time domain.
    //
    // This algorithm computes the following quantitated results and ratios:
    //
    // * Snr
    // * NAA
    // * Cr
    // * Ch
    // * mI
    // * H2O
    // * Noise
    // * NAA/Cr
    // * Cr/Cr
    // * Ch/Cr
    // * mI/Cr
    // * H20/Cr
    QuantResultsStructure quantResults;
    if(processingControl->Value<bool>("QuantitateSpectrum"))
    {
        quantResults = SingleVoxelQuant::QuantitateSpectrum(channelCombinedSignal, channelCombinedReference, *processingControl);
    }

    //// Spectral Transform
    // Transform to the frequency domain for plotting. A spectral filter is
    // applied prior to transforming.
    const float filterParameter = processingControl->Value<float>("SpectralFilterParameter");
    const ComplexFloatVector transformedData = Common::SingleVoxelTransform(channelCombinedSignal, transformSize, filterParameter, bandwidth);

    //// Plot data to an image and generate DICOM
    // This function will extract a region of interest to plot. The region
    // of interest is based on the user CVs 38 and 39 (rhuser38 and
    // rhuser39) which specify a lowest ppm to plot and a ppm range to
    // plot. These values can be overridden by changint the lowestPpmToPlot
    // and ppmRangeTopLot variables which are passed into this function.
    // This command plots the real components of the complex input 
    // spectrum.
    const ShortMatrix plottedSpectrum(SingleVoxelPlot::PlotData(transformedData, *processingControl, lowestPpmToPlot, ppmRangeToPlot));

    const int imageNumber = 0;
    
    const GERecon::ImageCorners imageCorners(pfilePointer->Corners(imageNumber), pfilePointer->Orientation(imageNumber));
    const GEDicom::MR::ImagePointer image = dicomSeries.NewImage(plottedSpectrum, imageNumber, imageCorners);

    if(processingControl->Value<bool>("QuantitateSpectrum"))
    {
        // TODO: Use generic Insert API for these values. May create helper function in Spectro to format DICOM value
        // std::string quantitatedValues = FormatQuantitatedValues(quantResults.naa, quantResults.cr, quantResults.ch, quantResults.mi, quantResults.water);
        const int precision = 6;
        std::stringstream quantitatedValues;
        quantitatedValues << std::setprecision(precision) << quantResults.naa << "\\" << quantResults.cr << "\\" << quantResults.ch << "\\" << quantResults.mi << "\\" << quantResults.water;
        image->Insert<GEDicom::DecimalString>(0x0043, 0x1093, quantitatedValues.str());
        
        std::stringstream quantitatedRatios;
        quantitatedRatios << std::setprecision(precision) << quantResults.naaRatio << "\\" << quantResults.crRatio << "\\" << quantResults.chRatio << "\\" << quantResults.miRatio << "\\" << quantResults.waterRatio;
        image->Insert<GEDicom::DecimalString>(0x0043, 0x1094, quantitatedRatios.str());

        std::stringstream spectroParams;
        spectroParams << std::setprecision(precision) << imageHeader.user6 << "\\" << quantResults.snr << "\\" <<  quantResults.noise;
        image->Insert<GEDicom::DecimalString>(0x0043, 0x108f, spectroParams.str());
    }

    // Save the single voxel image to the matlabDicom directory in the Pfile directory
    const boost::filesystem::path dicomFilePath = pfileFullFilePath.parent_path() / "cppDicom" / "Image_0000.dcm";
    image->Save(dicomFilePath);
}

void GERecon::Spectro::Rehearsal::ProcessFid(MDArray::ComplexFloatVector& cumulativePhaseCorrectionVector, MDArray::ComplexFloatVector& fidToProcess, const SingleVoxel::Options& processingParameters, const int transformSize)
{
    cumulativePhaseCorrectionVector = 1.0f;
    float appliedScalar = 1.0;

    //// Normalize
    // Divide each complex value in the FID by the maximum magnitude of the
    // FID. The scaled FID and  maximum magnitude scalar are returned. The 
    // maximum magnitude scalar may be used to scale the data back up at a 
    // later processing step if desired.
    if(processingParameters.normalize)
    {
        appliedScalar = Common::Normalize(fidToProcess);
    }
    
    //// Low Pass Filter
    // Filter the given FID with a low pass FIR filter. The FID is passed 
    // through the FIR filter once in the forward direction followed 
    // by once in the reverse direction. This results in zero phase 
    // distortion in the filtered FID and is analogous to MATLAB's filtfilt
    // function.
    if(processingParameters.lowPassFilter)
    {
        Common::LowPassFilter(fidToProcess);
    }
    
    //// Shift Max Frequency to DC
    // Applies a linear phase ramp to the input data to shift the frequency
    // with maximum magnitude to the DC location in the frequency domain.  
    // This is done by transforming the input data, finding the maximum 
    // magnitude point in frequency space, and constructing a linear phase 
    // shift correction vector that will bring the maximum magnitude point 
    // in the frequency domain to the DC frequency.  The correction vector 
    // is applied to the input data in the time domain.  The complex 
    // correction vector is also returned.
    if(processingParameters.shiftMaximumMagnitudeFrequencyToDc)
    {
        cumulativePhaseCorrectionVector = Common::ShiftMaximumMagnitudeFrequencyToDC(fidToProcess, transformSize);
    }

    //// Subtract First Point Phase
    // Compute the phase of the first point in the input FID and subtract 
    // that phase angle from all points in the FID. This results in the 
    // first point in the FID having a phase angle of zero. A phase 
    // correction vector with a constant complex value at each point is also 
    // returned. The constant complex value is the phase that was subtracted 
    // from each point in the input FID:
    //  $e^{(-i*phaseOfFirstPoint)}$
    if(processingParameters.subtractPhaseOfFirstPointInFid)
    {
        cumulativePhaseCorrectionVector *= Common::ShiftPhaseToMakeFirstPointInVectorHaveZeroPhase(fidToProcess);
    }
    
    //// Remove Linear Phase Trend
    // Estimates a linear phase trend by computing and unwrapping the phase
    // of the input FID. A linear phase ramp extending from the phase of the 
    // first point in the FID to the phase of the last point in the FID is 
    // constructed and subtracted from the input FID. The input FID with the 
    // linear phase trend removed and the phase correction vector are both 
    // returned. The correction vector is in complex format representing:
    //  $e^{-i*linearPhaseEstimateAtGivenPoint}$
    if(processingParameters.removeLinearPhaseTrend)
    {
        cumulativePhaseCorrectionVector *= Common::RemoveLinearPhase(fidToProcess);
    }

    //// Smoothed Phase Removal
    // Compute and unwrap the phase of the input vector. Smooth the phase
    // that exists across the FID using a spline smoothing function. The 
    // smoothed phase estimate is subtracted from the input vector. The 
    // input vector with the smoothed phase subtracted is returned. The 
    // smoothed phase vector that was subtracted from the input data is also 
    // returned. The phase correction vector is in complex format
    // representing:
    //  $e^{-i*smoothedPhaseEstimateAtGivenPoint}$
    if(processingParameters.smoothedPhaseRemoval)
    {
        cumulativePhaseCorrectionVector *= Common::PhaseUnwrapAndSmooth(fidToProcess);
    }
    
    //// Scale Data Up
    // If the FID was normalized above, scale the data back up by the same
    // amount the data was previously scaled down.
    if(processingParameters.normalize)
    {
        fidToProcess = fidToProcess * appliedScalar;
    }
}

void GERecon::Spectro::Rehearsal::GenerateChannelImages(const MDArray::ComplexFloatVector& combinedSignalFid, const MDArray::ComplexFloatVector& combinedReferenceFid, 
                                                        const float lowestPpmToPlot, const float ppmRangeToPlot, const GERecon::Control::ProcessingControl& processingControl, 
                                                        const GEHdf5::File& svDebugFile, const int channelIndex)
{
    const int numReferenceFids = processingControl.Value<int>("NumReferenceFIDs");
    const int acquiredFidLength = processingControl.Value<int>("AcquiredXRes");
    const int spectralTransformSize = processingControl.Value<int>("SpectralTransformSize");
    const int spectralBandwidth = processingControl.Value<int>("SpectralBandwidth");
    const float spectralFilterParameter = processingControl.Value<float>("SpectralFilterParameter");

    std::stringstream dataSetName;
    dataSetName << "channel_" << channelIndex;
    svDebugFile.Write(combinedSignalFid, dataSetName.str(), "combinedSignalFid");
    svDebugFile.Write(combinedReferenceFid, dataSetName.str(), "combinedReferenceFid");

    // check if we need to perform water subtraction, and perform if needed
    ComplexFloatVector referenceFidCopy(combinedReferenceFid.shape());
    referenceFidCopy = combinedReferenceFid;

    ComplexFloatVector signalFidCopy(combinedSignalFid.shape());
    signalFidCopy = combinedSignalFid;

    if(processingControl.Value<bool>("SubtractWater"))
    {
        Common::SubtractWater(referenceFidCopy, signalFidCopy, numReferenceFids, spectralBandwidth, acquiredFidLength, spectralTransformSize);
    }
    
    const ComplexFloatVector transformedData = Common::SingleVoxelTransform(signalFidCopy, spectralTransformSize, spectralFilterParameter, spectralBandwidth);

    const ShortMatrix plot(SingleVoxelPlot::PlotData(transformedData, processingControl, lowestPpmToPlot, ppmRangeToPlot));

    svDebugFile.Write(transformedData, dataSetName.str(), "transformedSpectrumVector");
    svDebugFile.Write(plot, dataSetName.str(), "plottedSpectrum");
}
